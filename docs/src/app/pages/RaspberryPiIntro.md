# Platform: Raspberry Pi

The “RaspberryPi” components consist of the “RaspberryPiServer” and the “RaspberryPiPinClient”. The “RaspberryPiServer” models the RaspberryPi board, whereas the “RaspberryPiPinClient”  models Raspberry Pi’s low level Digital Interfaces known as GPIO (General Purpose Input and Output) pins using a higher level programming abstraction offered by MIT App Inventor. These components are explained in detail in the App Inventor Components section. But very briefly, under the hood we use the MQTT protocol, to control the devices connected to the GPIO of the Raspberry Pi device from an app developed using MIT App Inventor. In the case of input sensors connected to the Raspberry Pi device, the data from these sensors will be relayed to phone app for processing as explained in the tutorials. 

## Setting up your RaspberryPi
### Essential Software

Download / clone the code available at this repo in to your RaspberryPi:<a rel="nofollow" href="https://github.com/thilankam/AppInventorRaspberryPiCompanion" target="_blank">https://github.com/thilankam/AppInventorRaspberryPiCompanion</a>.

### MQTT Broker
[Optional] If you wish to set up your RaspberryPi as an MQTT broker, we recommend that you install Mosquitto. Follow the instructions given on the Mosquitto website to run a broker locally. Please note that if you wish to control the devices and sensors connected to your RaspberryPi via the Internet with this approach, your RaspberryPi must have a public IP address.
 
Alternatively, you can use one of the public MQTT brokers listed here. If you wish to secure your payloads, you will need to use SSL ports. Those additional configurations steps are not covered here.

### Configuring RaspberryPiCompanion
The configuration options for the RaspberryPiCompnanion are located in the “rasperrypi-companion/src/main/resources/config.properties”. The contents of a sample configuration file is given below:

```javascript 
model=Pi2B
brokerAddress=iot.eclipse.org
brokerPort=1883
qos=2
identifierFile=identifier.txt
```

* The ‘model’ identifies the version of the RaspberryPi you are using.  
* The ‘brokerAddress’ and ‘brokerPort’ can be the settings for the MQTT broker you set up or one of the publicly available brokers.  

* The ‘qos’ identifies the quality of service of the messages sent from the raspberry pi device.  

* The ‘identifierFile’ caches the unique identifier generated by the companion. If you wish to reset the identifier, simply delete the file given as the value to ‘identifierFile’ (in this case that would be identifier.txt), or clear the contents of the file.  


## Set up Logging
Optionally, you can set up the formatting and the location of the logging output in “rasperrypi-companion/src/main/resources/log4j.properties” file. By default the logging output will be appended to the console. You can configure it to send the log output to a file, etc. More information on log4j and how to configure the log4j.properties can be found  <a rel="nofollow" href="http://logging.apache.org/log4j/2.x/" target="_blank">here.</a>



## Run the RaspberryPiAppInventorCompanion
Please run the script “rasperrypi-companion/output.sh”. 
In order to tether the phone app and RaspberryPi together, we need a unique identifier and that is generated by the RaspberryPiAppInventorCompanion. This identifier is cached in a file and reused to avoid having to enter a new identifier every time the RasperryPiAppInventorCompanion is restarted. In order to clear this identifier, the user may simply delete the file that stores the identifier. Instructions are displayed in the RaspberryPiAppInventorCompanionServer as shown below:

 
> ***********************************************************************************************
> RaspberryPiCompanion Server for  App Inventor starting...
>  
> Please copy and paste the following string for the 'identifier' parameter 
> in the 'Initialize' method block of your RaspberryPiServer component:
>  
> 42dc4509-9150-4306-b816-f8340e95e1db
>  
> (If you wish to reset this identifier, delete the cached identifier file available at: 
> /home/pi/thilanka/Projects/rasperrypi-companion/identifier.txt
> and restart the companion application.) 
> ***********************************************************************************************

## Subscribing and Publishing to Topics via MQTT
One important consideration when designing the RaspberryPiServer component is that the pin client and the server should communicate via the same topic, while allowing the flexibility to use any arbitrary topic. Therefore, for any internal topic communicated via the App Inventor, we utilizes the identifier (for e.g. 42dc4509-9150-4306-b816-f8340e95e1db as shown above). This also indirectly helps us to avoid any potential message collisions when using a public MQTT broker when controlling the devices connected to the RaspberryPiServer via the Internet.  


# App Inventor Components
The main component necessary to support the Raspberry Pi in App Inventor is the ‘RaspberryPiServer’ component. Each device connected to the Raspberry Pi can be modeled using the ‘RaspberryPiPinClient’ component.  

## RaspberryPiServer
Extensive details about the available properties, methods, and events can be found here. Therefore, we will not discuss them <a rel="nofollow" href="https://docs.google.com/document/d/1AzBV36rJg7dyHWAOJNvxOadOa7NXaQPUpm_9Zn_rhWw/edit#">here.</a>. Instead, we will focus on how to configure the RaspberryPiServer component. 

## Component Configuration 
Before using the RaspberryPiServer component, we have to initialize the component with certain parameters to make sure the Raspberry Pi and the corresponding App Inventor component will work together. For example, if the ‘model’ specified in the config.properties is “Pi2B”, the same value must be specified in the initialize block of the RaspberryPiServer component. Similarly the ‘brokerAddress’ and ‘brokerPort’ should match. Most importantly, the ‘identifier’ has to be identical with what is available in identifier.txt file created in the RaspberryPi and output when the companion first starts. A runtime will error result if any of these values do not match. 

![intializeServer RaspberryPiServer1](images/RaspberryPi.ComponentConfiguration.png)

 ## RaspberryPiPinClient
 
RaspberryPiPinClient component will allow the users to choose the available GPIO pins to make as an input or as an output. The pins can be in either “High” or “Low” state. 
* “High” represents a positive voltage (for Raspberry Pi, it is +3.3 Volts DC). 
* “Low” represents the zero voltage. However, if you don’t apply a bias to that pin, the voltage value can float, which means, it can be anywhere between zero and a positive voltage, which can confuse GPIO inputs, Therefore you really need to provide 
pull-up or pull-down resistance depending on the circuit you are designing.

Extensive details about the available properties, methods, and events can be found here. Therefore, we will not discuss them <a rel="nofollow" href="https://docs.google.com/document/d/1AzBV36rJg7dyHWAOJNvxOadOa7NXaQPUpm_9Zn_rhWw/edit#heading=h.itpzq6e87203">here.</a> here. Instead, we will focus on how to configure the RaspberryPiPinClient component and some of the design decisions taken such as the pin numbering followed.

## Component Configuration 

![intializeClient RaspberryPiServer1](images/RaspberryPi.ClientComponentConfiguration.png)

A RaspberryPiPinClient used in AppInventor must be registered. The method block that can be used to register the pin client is shown in the above image. The ‘pin’ parameter specifies the physical pin number used in the configuration. The ‘isOutput’ parameter specifies whether the device connected to the pin is an output or an input. The ‘raspberryPiServer’ parameter specifies the RaspberryPiServer that this pin is attached to. This is important in validating the pin and also obtaining the MQTT broker IP address and the port used to send and receive messages.

## Pin Numbering
There are several Raspberry Pi models available now with different numbers of pins. For example:

 *  Pi1A = 26 GPIO
 *  Pi1B = 26 GPIO
 *  Pi1A+ = 40 GPIOs 
 *  Pi1B+ =   40 GPIOs
 *  Pi2B = 40 GPIOs
 *  Pi3B = 40 GPIOs


Some Raspberry Pi GPIO implementations use different pin configurations to be compatible across different Raspberry Pi boards. For example, the BCM or the commonly called “GPIO” pin number differs from the physical pin number on the header. In order to keep the pin numbering consistent and less confusing in the MIT AI implementation, the same pin numbering as can be seen on the board, i.e. the number corresponding to the pin's physical location on the header is used to identify the RaspberryPiPinClient. However, this means that the app developer has to specify the board he/she is using as explained in the RaspberryPiServer component section. Based on this input, the component will perform pin validation and notify the app developer of any discrepancy. For example, if the app is for the Raspberry Pi  model A, pin 27 is invalid, although the same pin is a valid pin in Raspberry Pi 2 Model B. 

<div style="text-align: center; font-size: 75%; margin: 16pt 0;">
![raspberry:pi P1 Header](./images/RaspberryPi.ABP1Header.png)
![raspberry:pi J8 Header](./images/RaspberryPi.ABJ8Header.png)
<br>
Different Raspberry Pi boards with different Pin Configurations
</div>